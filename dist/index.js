import{Buffer as v}from"node:buffer";import{EventEmitter as x}from"node:events";import y from"imap";import{simpleParser as E}from"mailparser";var a=class extends x{imap;options;msgUidMap=new Map;fetchUnread=!1;retryTimes=3;constructor(t,e=!1){if(!t)throw new Error("options is required!");super(),this.options=t,this.fetchUnread=e,this.imap=this._setupImap()}_setupImap(){let t=this,{user:e,password:o,host:r,port:n}=t.options,s=new y({user:e,password:o,host:r,port:Number.parseInt(n,10),tls:!0,tlsOptions:{rejectUnauthorized:!1},keepalive:{forceNoop:!0}});return s.on("ready",()=>{this.openInbox()}),s.on("error",i=>{t.retryTimes>0&&(t.retryTimes--,s.destroy(),t.imap=t._setupImap())}),s.on("log",console.log),s}openInbox(){let t=this;t.imap.openBox("INBOX",!1,(e,o)=>{if(e)throw e;t.retryTimes=3,t.fetchUnread&&t.fetchUnreadEmails(),t.imap.on("mail",r=>{t.fetchLatestEmails(o,r)})})}fetchUnreadEmails(){let t=this;t.imap.search(["UNSEEN"],(e,o)=>{if(e)throw e;o?.length&&t.fetchEmails(o)})}fetchLatestEmails(t,e){let o=this,r=t.messages.total,n=`${Math.max(1,r-e+1)}:${r}`;o.fetchEmails(n)}fetchEmails(t){let e=this,o=e.imap.seq.fetch(t,{bodies:"",struct:!0,markSeen:!0});o.on("message",(r,n)=>{r.on("body",(s,i)=>{e.parseEmail(s,i.size,n)}),r.on("attributes",s=>{let{uid:i}=s;e.msgUidMap.set(n,i)}),r.on("end",()=>{})}),o.on("error",r=>{throw r}),o.on("end",()=>{})}parseEmail(t,e,o){let r=this,n=v.alloc(e),s=0;t.on("data",i=>{i.copy(n,s),s+=i.length}),t.on("end",()=>{E(n).then(i=>{let{subject:l,text:c,html:f,attachments:h,from:u}=i,g=u?.value.map(b=>b.address).filter(Boolean),d=r.msgUidMap.get(o);l&&r.emit(l,{msgUid:d,text:c,html:f,attachments:h,from:g}),r.msgUidMap.delete(o)})}),t.on("error",i=>{})}start(){this.imap.connect()}stop(){this.imap.end(),this.imap.destroy(),this.msgUidMap.clear()}use(){}markAsRead(t){return new Promise((e,o)=>{this.imap.seq.addFlags(t,"\\Seen",r=>{r?o(r):e(!0)})})}useCmds(t){let e=this;t.forEach(o=>{e.on(o.command,o.action)})}log(){}};import{createTransport as w}from"nodemailer";var p=class{transport;constructor(t){if(!t)throw new Error("options is required!");let{user:e,password:o,smtphost:r,smtpport:n,proxy:s}=t,i={pool:!0,host:r,port:n,secure:!0,auth:{user:e,pass:o},proxy:s};this.transport=w(i)}testTransport(){return new Promise((t,e)=>{this.transport.verify((o,r)=>{o?e(o):t(r)})})}send(t,e,o,r,n){return this.transport.sendMail({from:t,to:e,subject:o,text:r,html:n})}};export{a as EmailListener,p as EmialSender};
