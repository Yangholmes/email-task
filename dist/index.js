import{Buffer as d}from"node:buffer";import{EventEmitter as f}from"node:events";import b from"imap";import{simpleParser as x}from"mailparser";var l=class extends f{imap;options;msgUidMap=new Map;constructor(t){if(!t)throw new Error("options is required!");super(),this.options=t,this.imap=this._setupImap()}_setupImap(){let t=this,{user:e,password:o,host:r,port:i}=t.options,n=new b({user:e,password:o,host:r,port:Number.parseInt(i,10),tls:!0,tlsOptions:{rejectUnauthorized:!1}});return n.on("ready",()=>{this.openInbox()}),n.on("error",s=>{}),n.on("log",console.log),n}openInbox(){let t=this;t.imap.openBox("INBOX",!1,(e,o)=>{if(e)throw e;t.imap.on("mail",r=>{t.fetchLatestEmails(o,r)})})}fetchLatestEmails(t,e){let o=this,r=t.messages.total,i=`${Math.max(1,r-e+1)}:${r}`,n=o.imap.seq.fetch(i,{bodies:"",struct:!0,markSeen:!0});n.on("message",(s,a)=>{s.on("body",(p,m)=>{o.parseEmail(p,m.size,a)}),s.on("attributes",p=>{let{uid:m}=p;o.msgUidMap.set(a,m)}),s.on("end",()=>{})}),n.on("error",s=>{throw s}),n.on("end",()=>{})}parseEmail(t,e,o){let r=this,i=d.alloc(e),n=0;t.on("data",s=>{s.copy(i,n),n+=s.length}),t.on("end",()=>{x(i).then(s=>{let{subject:a,text:p,html:m,attachments:g}=s,h=r.msgUidMap.get(o);a&&r.emit(a,{msgUid:h,text:p,html:m,attachments:g}),r.msgUidMap.delete(o)})}),t.on("error",s=>{})}start(){this.imap.connect()}stop(){this.imap.end(),this.msgUidMap.clear()}use(){}markAsRead(t){return new Promise((e,o)=>{this.imap.seq.addFlags(t,"\\Seen",r=>{r?o(r):e(!0)})})}useCmds(t){let e=this;t.forEach(o=>{e.on(o.command,o.action)})}};import{createTransport as w}from"nodemailer";var c=class{transport;constructor(t){if(!t)throw new Error("options is required!");let{user:e,password:o,smtphost:r,smtpport:i,proxy:n}=t,s={pool:!0,host:r,port:i,secure:!0,auth:{user:e,pass:o},proxy:n};this.transport=w(s)}testTransport(){return new Promise((t,e)=>{this.transport.verify((o,r)=>{o?e(o):t(r)})})}send(t,e,o,r,i){return this.transport.sendMail({from:t,to:e,subject:o,text:r,html:i})}};export{l as EmailListener,c as EmialSender};
