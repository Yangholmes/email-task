import{Buffer as x}from"node:buffer";import{EventEmitter as E}from"node:events";import v from"imap";import{simpleParser as w}from"mailparser";var a=class extends E{imap;options;msgUidMap=new Map;fetchUnread=!1;constructor(t,o=!1){if(!t)throw new Error("options is required!");super(),this.options=t,this.fetchUnread=o,this.imap=this._setupImap()}_setupImap(){let t=this,{user:o,password:e,host:r,port:s}=t.options,n=new v({user:o,password:e,host:r,port:Number.parseInt(s,10),tls:!0,tlsOptions:{rejectUnauthorized:!1}});return n.on("ready",()=>{this.openInbox()}),n.on("error",i=>{}),n.on("log",console.log),n}openInbox(){let t=this;t.imap.openBox("INBOX",!1,(o,e)=>{if(o)throw o;t.fetchUnread&&t.fetchUnreadEmails(),t.imap.on("mail",r=>{t.fetchLatestEmails(e,r)})})}fetchUnreadEmails(){let t=this;t.imap.search(["UNSEEN"],(o,e)=>{if(o)throw o;e?.length&&t.fetchEmails(e)})}fetchLatestEmails(t,o){let e=this,r=t.messages.total,s=`${Math.max(1,r-o+1)}:${r}`;e.fetchEmails(s)}fetchEmails(t){let o=this,e=o.imap.seq.fetch(t,{bodies:"",struct:!0,markSeen:!0});e.on("message",(r,s)=>{r.on("body",(n,i)=>{o.parseEmail(n,i.size,s)}),r.on("attributes",n=>{let{uid:i}=n;o.msgUidMap.set(s,i)}),r.on("end",()=>{})}),e.on("error",r=>{throw r}),e.on("end",()=>{})}parseEmail(t,o,e){let r=this,s=x.alloc(o),n=0;t.on("data",i=>{i.copy(s,n),n+=i.length}),t.on("end",()=>{w(s).then(i=>{let{subject:l,text:c,html:f,attachments:h,from:u}=i,g=u?.value.map(b=>b.address).filter(Boolean),d=r.msgUidMap.get(e);l&&r.emit(l,{msgUid:d,text:c,html:f,attachments:h,from:g}),r.msgUidMap.delete(e)})}),t.on("error",i=>{})}start(){this.imap.connect()}stop(){this.imap.end(),this.msgUidMap.clear()}use(){}markAsRead(t){return new Promise((o,e)=>{this.imap.seq.addFlags(t,"\\Seen",r=>{r?e(r):o(!0)})})}useCmds(t){let o=this;t.forEach(e=>{o.on(e.command,e.action)})}};import{createTransport as M}from"nodemailer";var p=class{transport;constructor(t){if(!t)throw new Error("options is required!");let{user:o,password:e,smtphost:r,smtpport:s,proxy:n}=t,i={pool:!0,host:r,port:s,secure:!0,auth:{user:o,pass:e},proxy:n};this.transport=M(i)}testTransport(){return new Promise((t,o)=>{this.transport.verify((e,r)=>{e?o(e):t(r)})})}send(t,o,e,r,s){return this.transport.sendMail({from:t,to:o,subject:e,text:r,html:s})}};export{a as EmailListener,p as EmialSender};
